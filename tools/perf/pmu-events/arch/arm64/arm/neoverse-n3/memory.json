[
    {
        "ArchStdEvent": "MEM_ACCESS",
        "PublicDescription": "Counts memory accesses issued by the CPU load store unit, where those accesses are issued due to load or store operations. This event counts memory accesses no matter whether the data is received from any level of cache hierarchy or external memory. If memory accesses are broken up into smaller transactions than what were specified in the load or store instructions, then the event counts those smaller memory transactions."
    },
    {
        "ArchStdEvent": "REMOTE_ACCESS",
        "PublicDescription": "Counts accesses to another chip, which is implemented as a different CMN mesh in the system. If the CHI bus response back to the core indicates that the data source is from another chip (mesh), then the counter is updated. If no data is returned, even if the system snoops another chip/mesh, then the counter is not updated."
    },
    {
        "ArchStdEvent": "MEM_ACCESS_RD",
        "PublicDescription": "Counts memory accesses issued by the CPU due to load operations. The event counts any memory load access, no matter whether the data is received from any level of cache hierarchy or external memory. The event also counts atomic load operations. If memory accesses are broken up by the load/store unit into smaller transactions that are issued by the bus interface, then the event counts those smaller transactions."
    },
    {
        "ArchStdEvent": "MEM_ACCESS_WR",
        "PublicDescription": "Counts memory accesses issued by the CPU due to store operations. The event counts any memory store access, no matter whether the data is located in any level of cache or external memory. The event also counts atomic load and store operations. If memory accesses are broken up by the load/store unit into smaller transactions that are issued by the bus interface, then the event counts those smaller transactions."
    },
    {
        "ArchStdEvent": "LDST_ALIGN_LAT",
        "PublicDescription": "Counts the number of memory read and write accesses in a cycle that incurred additional latency, due to the alignment of the address and the size of data being accessed, which results in store crossing a single cache line."
    },
    {
        "ArchStdEvent": "LD_ALIGN_LAT",
        "PublicDescription": "Counts the number of memory read accesses in a cycle that incurred additional latency, due to the alignment of the address and size of data being accessed, which results in load crossing a single cache line."
    },
    {
        "ArchStdEvent": "ST_ALIGN_LAT",
        "PublicDescription": "Counts the number of memory write access in a cycle that incurred additional latency, due to the alignment of the address and size of data being accessed incurred additional latency."
    },
    {
        "ArchStdEvent": "MEM_ACCESS_CHECKED",
        "PublicDescription": "Counts the number of memory read and write accesses counted by MEM_ACCESS that are tag checked by the Memory Tagging Extension (MTE). This event is implemented as the sum of MEM_ACCESS_CHECKED_RD and MEM_ACCESS_CHECKED_WR"
    },
    {
        "ArchStdEvent": "MEM_ACCESS_CHECKED_RD",
        "PublicDescription": "Counts the number of memory read accesses in a cycle that are tag checked by the Memory Tagging Extension (MTE)."
    },
    {
        "ArchStdEvent": "MEM_ACCESS_CHECKED_WR",
        "PublicDescription": "Counts the number of memory write accesses in a cycle that is tag checked by the Memory Tagging Extension (MTE)."
    },
    {
        "ArchStdEvent": "INST_FETCH_PERCYC",
        "PublicDescription": "Counts number of instruction fetches outstanding per cycle, which will provide an average latency of instruction fetch."
    },
    {
        "ArchStdEvent": "MEM_ACCESS_RD_PERCYC",
        "PublicDescription": "Counts the number of outstanding loads or memory read accesses per cycle."
    },
    {
        "ArchStdEvent": "INST_FETCH",
        "PublicDescription": "Counts Instruction memory accesses that the PE makes."
    }
]
